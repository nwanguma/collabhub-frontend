{"version":3,"file":"route.js","sourceRoot":"/","sources":["app/api/auth/[...nextauth]/route.ts"],"names":[],"mappings":";;;;;;AAAA,0DAAqE;AACrE,kFAAkE;AAClE,kDAA0B;AAsB1B,MAAM,WAAW,GAAoB;IACnC,SAAS,EAAE;QACT,IAAA,qBAAmB,EAAC;YAClB,IAAI,EAAE,aAAa;YACnB,WAAW,EAAE;gBACX,KAAK,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE;gBACvC,QAAQ,EAAE,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE;gBACjD,KAAK,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE;aACzC;YACD,KAAK,CAAC,SAAS,CACb,WAAyB;gBAEzB,IAAI,CAAC,WAAW;oBAAE,OAAO,IAAI,CAAC;gBAE9B,IAAI,eAAe,CAAC;gBAEpB,IACE,WAAW,CAAC,KAAK;oBACjB,WAAW,CAAC,KAAK,KAAK,OAAO,CAAC,GAAG,CAAC,gBAAgB,EAClD,CAAC;oBACD,eAAe,GAAG;wBAChB,KAAK,EAAE,OAAO,CAAC,GAAG,CAAC,gBAAgB;wBACnC,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,mBAAmB;qBAC1C,CAAC;gBACJ,CAAC;qBAAM,CAAC;oBACN,eAAe,GAAG;wBAChB,KAAK,EAAE,WAAW,CAAC,KAAK;wBACxB,QAAQ,EAAE,WAAW,CAAC,QAAQ;qBAC/B,CAAC;gBACJ,CAAC;gBAED,IAAI,CAAC;oBACH,MAAM,QAAQ,GAAG,MAAM,eAAK,CAAC,IAAI,CAC/B,GAAG,OAAO,CAAC,GAAG,CAAC,WAAW,aAAa,EACvC,eAAe,EACf;wBACE,OAAO,EAAE;4BACP,kBAAkB,EAAE,OAAO,CAAC,GAAG,CAAC,cAAc;yBAC/C;qBACF,CACF,CAAC;oBAEF,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;oBAEnC,IAAI,MAAM,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE,CAAC;wBACtC,OAAO;4BACL,GAAG,MAAM,CAAC,IAAI;4BACd,WAAW,EAAE,MAAM,CAAC,YAAY;yBAGjC,CAAC;oBACJ,CAAC;gBACH,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,OAAO,IAAI,CAAC;gBACd,CAAC;gBAED,OAAO,IAAI,CAAC;YACd,CAAC;SACF,CAAC;KACH;IACD,MAAM,EAAE,OAAO,CAAC,GAAG,CAAC,eAAe;IACnC,SAAS,EAAE;QACT,KAAK,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,IAAI,EAA8C;YACnE,IAAI,IAAI,EAAE,CAAC;gBACT,MAAM,gBAAgB,GAAG,CAAC,IAAU,EAA0B,EAAE,CAC7D,IAAuB,CAAC,WAAW,KAAK,SAAS,CAAC;gBAErD,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC3B,OAAO;wBACL,WAAW,EAAE,IAAI,CAAC,WAAW;qBAG9B,CAAC;gBACJ,CAAC;YACH,CAAC;YAWD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,KAAK,CAAC,OAAO,CAAC,EACZ,OAAO,EACP,KAAK,GAIN;YACC,MAAM,eAAe,GAAG,KAAc,CAAC;YACvC,OAAO,CAAC,WAAW,GAAG,eAAe,CAAC,WAAW,CAAC;YACjD,OAAe,CAAC,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC;YAE/C,OAAO,OAAO,CAAC;QACjB,CAAC;KACF;IAED,OAAO,EAAE;QACP,QAAQ,EAAE,KAAK;QACf,MAAM,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;KAC1B;IAED,KAAK,EAAE;QACL,MAAM,EAAE,cAAc;QACtB,KAAK,EAAE,aAAa;KACrB;IAED,KAAK,EAAE,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,aAAa;CAC9C,CAAC;AAEF,KAAK,UAAU,kBAAkB,CAAC,KAAY;IAC5C,IAAI,CAAC;QACH,MAAM,QAAQ,GAAG,MAAM,eAAK,CAAC,IAAI,CAC/B,GAAG,OAAO,CAAC,GAAG,CAAC,WAAW,eAAe,EACzC;YACE,aAAa,EAAE,KAAK,CAAC,YAAY;SAClC,EACD;YACE,OAAO,EAAE;gBACP,aAAa,EAAE,UAAU,KAAK,EAAE,WAAW,EAAE;gBAC7C,kBAAkB,EAAE,OAAO,CAAC,GAAG,CAAC,cAAc;aAC/C;SACF,CACF,CAAC;QAEF,MAAM,eAAe,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;QAE3C,OAAO;YACL,GAAG,KAAK;YACR,WAAW,EAAE,eAAe,CAAC,YAAY;SAG1C,CAAC;IACJ,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,gCAAgC,EAAE,KAAK,CAAC,CAAC;QAEvD,OAAO;YACL,GAAG,KAAK;YACR,KAAK,EAAE,yBAAyB;SACjC,CAAC;IACJ,CAAC;AACH,CAAC;AAED,MAAM,OAAO,GAAG,IAAA,mBAAQ,EAAC,WAAW,CAAC,CAAC;AAElB,sBAAG;AAAa,uBAAI","sourcesContent":["import NextAuth, { NextAuthOptions, User, Session } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport axios from \"axios\";\nimport { JWT } from \"next-auth/jwt\";\n\ninterface Credentials {\n  email?: string;\n  password?: string;\n  token?: string;\n}\n\ninterface Token extends JWT {\n  accessToken: string;\n  refreshToken: string;\n  accessTokenExpires: number;\n  error?: string;\n}\n\ninterface UserWithTokens extends User {\n  accessToken: string;\n  refreshToken: string;\n  accessTokenExpires: number;\n}\n\nconst authOptions: NextAuthOptions = {\n  providers: [\n    CredentialsProvider({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" },\n        token: { label: \"Token\", type: \"token\" },\n      },\n      async authorize(\n        credentials?: Credentials\n      ): Promise<UserWithTokens | null> {\n        if (!credentials) return null;\n\n        let authCredentials;\n\n        if (\n          credentials.token &&\n          credentials.token === process.env.GUEST_AUTH_TOKEN\n        ) {\n          authCredentials = {\n            email: process.env.GUEST_AUTH_EMAIL,\n            password: process.env.GUEST_AUTH_PASSWORD,\n          };\n        } else {\n          authCredentials = {\n            email: credentials.email,\n            password: credentials.password,\n          };\n        }\n\n        try {\n          const response = await axios.post(\n            `${process.env.BACKEND_URL}/auth/login`,\n            authCredentials,\n            {\n              headers: {\n                \"x-client-api-key\": process.env.CLIENT_API_KEY,\n              },\n            }\n          );\n\n          const result = response.data?.data;\n\n          if (result && response.status === 201) {\n            return {\n              ...result.user,\n              accessToken: result.access_token,\n              // refreshToken: result.refresh_token,\n              // accessTokenExpires: Date.now() + result.expires_in * 1000,\n            };\n          }\n        } catch (error) {\n          return null;\n        }\n\n        return null;\n      },\n    }),\n  ],\n  secret: process.env.NEXTAUTH_SECRET,\n  callbacks: {\n    async jwt({ token, user }: { token: JWT; user?: User; account?: any }) {\n      if (user) {\n        const isUserWithTokens = (user: User): user is UserWithTokens =>\n          (user as UserWithTokens).accessToken !== undefined;\n\n        if (isUserWithTokens(user)) {\n          return {\n            accessToken: user.accessToken,\n            // refreshToken: user.refreshToken,\n            // accessTokenExpires: user.accessTokenExpires,\n          };\n        }\n      }\n\n      // if (\n      //   (token as Token).accessToken &&\n      //   Date.now() < (token as Token).accessTokenExpires\n      // ) {\n      // return token;\n      // }\n\n      // return refreshAccessToken(token as Token);\n\n      return token;\n    },\n\n    async session({\n      session,\n      token,\n    }: {\n      session: Session;\n      token: JWT | Token;\n    }): Promise<Session> {\n      const tokenWithAccess = token as Token;\n      session.accessToken = tokenWithAccess.accessToken;\n      (session as any).error = tokenWithAccess.error;\n\n      return session;\n    },\n  },\n\n  session: {\n    strategy: \"jwt\",\n    maxAge: 30 * 24 * 60 * 60,\n  },\n\n  pages: {\n    signIn: \"/auth/signin\",\n    error: \"/auth/error\",\n  },\n\n  debug: process.env.NODE_ENV === \"development\",\n};\n\nasync function refreshAccessToken(token: Token): Promise<Token> {\n  try {\n    const response = await axios.post(\n      `${process.env.BACKEND_URL}/auth/refresh`,\n      {\n        refresh_token: token.refreshToken,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${token?.accessToken}`,\n          \"x-client-api-key\": process.env.CLIENT_API_KEY,\n        },\n      }\n    );\n\n    const refreshedTokens = response.data.data;\n\n    return {\n      ...token,\n      accessToken: refreshedTokens.access_token,\n      // accessTokenExpires: Date.now() + refreshedTokens.expires_in * 1000,\n      // refreshToken: refreshedTokens.refresh_token ?? token.refreshToken,\n    };\n  } catch (error) {\n    console.error(\"Error refreshing access token:\", error);\n\n    return {\n      ...token,\n      error: \"RefreshAccessTokenError\",\n    };\n  }\n}\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST };\n"]}